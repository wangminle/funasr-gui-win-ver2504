# FunASR Python客户端的简单需求说明书

这是一个使用 Python 和 Tkinter 库创建一个简单 GUI 客户端的方案，该客户端将调用您提供的 `funasr_wss_client.py` 脚本来与 FunASR runtime 服务器交互。

## 功能描述
1. GUI框架：脚本信息一目了然，可以在windows环境执行；
2. 服务连接：提供websocker的SSL连接服务，支持手动修改网址和端口地址；
3. 选择本地文件并发送脚本：将选中的文件发送到服务器的api端口；
4. 接收文本结果：按照接口协议接收结果，并将最终结果显示在软件的输出文本框中。

**方案概述:**

1.  **GUI 框架:** 使用 Python 内置的 `tkinter` 库来创建图形用户界面。
    *   默认800x600大小的整体窗口；
    *   可以全屏或者缩小至初始大小；
    *   有“网络连接”，“开始识别”，“导出结果”等按钮。
    *   UI的具体内容见文档：C:\Users\wangminle\Documents\VSCode\2-Cursor实战记录\2-FunASR-practice\funasr-gui-win-ver2504\prd\funasr-python-gui-client-v2-UI定义.md
2.  **用户输入:**
    *   提供输入框让用户指定 FunASR runtime 服务器的 IP 地址和端口号。
    *   提供一个按钮，允许用户浏览并选择本地的音频或视频文件。
    *   显示用户选择的文件路径。
3.  **执行脚本:**
    *   添加一个“开始识别”按钮。
    *   点击按钮时，GUI 程序会收集用户输入的服务器地址、端口和文件路径。
    *   使用 Python 的 `subprocess` 模块在后台启动 `funasr_wss_client.py` 脚本，并将收集到的信息作为命令行参数传递给它（例如 `--host`, `--port`, `--audio_in`, `--mode offline`）。
4.  **结果输出** 
    *   添加一个文本框，用于显示 `funasr_wss_client.py` 脚本的输出或错误信息。
5.  **状态显示:**
    *   添加一个状态栏，用于显示操作状态（如“正在识别…”）等连接或工作状态；
6.  **线程处理:** 为了防止在执行识别任务时 GUI 界面卡死，将在一个单独的线程中运行 `subprocess`。

**实现步骤:**

1.  **创建 Python 文件:** 创建一个新的 Python 文件（例如 `funasr_gui_client.py`）。
2.  **编写 GUI 代码:** 使用 `tkinter` 构建界面元素（标签、输入框、按钮、文本框）。
3.  **实现文件选择功能:** 使用 `tkinter.filedialog.askopenfilename`。
4.  **实现“开始识别”按钮的回调函数:**
    *   获取界面上的输入值。
    *   构建 `funasr_wss_client.py` 的命令行参数列表。
    *   创建一个新线程来执行 `subprocess.run`（或 `subprocess.Popen`）调用 `funasr_wss_client.py`。
    *   在线程中捕获脚本的标准输出和标准错误。
    *   将状态和脚本输出更新到 GUI 的文本区域（注意：从非主线程更新 Tkinter 控件需要使用 `widget.after` 或类似机制）。

**注意事项:**

*   **`funasr_wss_client.py` 的位置:** 这个 GUI 脚本需要能够找到并执行 `funasr_wss_client.py`。最简单的方式是将它们放在同一个目录下，或者确保 `funasr_wss_client.py` 所在的目录在系统的 PATH 环境变量中。
*   **Python 环境:** 运行此 GUI 脚本的 Python 环境需要安装 `funasr_wss_client.py` 所需的所有依赖。
*   **错误处理:** 需要添加适当的错误处理，例如检查用户输入是否有效，以及处理 `subprocess` 执行过程中可能出现的异常。
*   **输出:** `funasr_wss_client.py` 的输出将直接显示在 GUI 的文本框中。如果该脚本将结果写入文件（如使用 `--output_dir`），GUI 不会直接显示文件内容，只会显示脚本执行过程的标准输出。


## 第二阶段开发建议

好的，我们来探讨一下 `funasr-gui-client-v2` 项目的下一步改进方向。你提到的几个点都非常有价值，结合我对现有代码和 FunASR 客户端能力的理解，我提出以下建议：

**1. 状态栏信息优化与分类:**

*   **现状:** 状态栏 (`self.status_var`) 目前显示比较简单的文本信息，如 "准备就绪"、"正在连接..." 等。连接状态有单独的颜色指示器。
*   **改进建议:**
    *   **更详细的进度反馈:** 在文件识别过程中，状态栏可以显示更具体的阶段，例如：“正在读取文件...”、“正在上传音频 (x%)...”、“服务器处理中...”、“正在接收结果...”。这需要 GUI 与后端脚本 (`simple_funasr_client.py` 或直接的 WebSocket 连接) 之间有更紧密的通信，可能需要修改脚本以输出更详细的进度信息，或者将 WebSocket 逻辑直接集成到 GUI 的后台线程中。
    *   **分类与视觉提示:** 可以借鉴连接指示器的做法，对状态栏信息进行分类。
        *   **成功/完成:** 使用绿色文本或图标 (✓)。
        *   **进行中/提示:** 使用蓝色或默认颜色文本，或添加旋转图标。
        *   **警告/注意:** 使用橙色文本或图标 (!)。
        *   **错误:** 使用红色文本或图标 (X)。
    *   **短暂信息与持久信息:** 短暂的操作提示（如“文件已选择”）可以显示几秒后恢复默认状态（如“准备就绪”），而重要的状态（如“识别完成”、“连接错误”）应保持显示直到下一次操作开始。

**2. 上传速度与分块大小:**

*   **现状:** GUI 目前硬编码调用 `simple_funasr_client.py` 时使用 `--mode offline`，并且没有传递 `--chunk_size` 或 `--chunk_interval` 参数，这些参数在 `simple_funasr_client.py` 中有默认值 (`5, 10, 5` 和 `10`)。`simple_funasr_client.py` 在 offline 模式下会按 `stride` (基于 `chunk_size[1]` 和 `chunk_interval` 计算) 切分数据块发送，并在块之间有极短的 `sleep(0.001)`。`--send_without_sleep` 参数存在但 GUI 未使用。
*   **改进建议:**
    *   **区分模式:** 首先要明确，`--chunk_size` 和 `--chunk_interval` 主要影响的是 `online` 和 `2pass` 模式下的**实时性（延迟）**，而非 `offline` 模式下的**总上传速度**。对于 `offline` 模式，目标是尽快上传完整文件。
    *   **优化 Offline 上传:**
        *   在 GUI 调用 `simple_funasr_client.py` 进行 `offline` 识别时，应考虑传递 `--send_without_sleep` 参数，或者修改 `simple_funasr_client.py`，在 offline 模式下移除块间 `sleep`，让 WebSocket 库或操作系统 TCP 栈自行处理流控，理论上能更快地发送数据。
        *   暴露 `--thread_num` 参数：如果用户处理 `.scp` 文件（多文件列表），允许多线程上传 (`--thread_num`) 可以显著提高整体处理速度。可以在“高级选项”中添加一个数字输入框来设置并发线程数。
    *   **暴露 Online/2Pass 参数 (如果支持这些模式):** 如果未来 GUI 支持 `online` 或 `2pass` 模式，那么需要在“高级选项”中允许用户配置 `--chunk_size` 和 `--chunk_interval`，并提供合理的默认值和说明（例如，解释它们如何影响延迟和计算量）。
    *   **直接 WebSocket 集成 (高级):** 为了更精细地控制上传过程、获取进度并可能进一步优化，可以考虑将 `simple_funasr_client.py` 的核心 WebSocket 逻辑直接整合到 `funasr_gui_client_v2.py` 的后台线程中，避免 `subprocess` 开销和通信复杂性。

**3. 结果输出与日志分离:**

*   **现状:** 所有信息（状态更新、脚本的标准输出/错误、最终识别结果）都混合在同一个 `ScrolledText` (`self.output_text`) 中。
*   **改进建议:**
    *   **强烈建议分离:** 这是提高可用性的重要一步。可以使用 `ttk.Notebook` (选项卡) 或 `tk.PanedWindow` (可拖动分隔条) 将界面分为至少两个区域：
        *   **“识别结果”区域:** 只显示最终的、格式化好的识别文本。例如，对于 `offline` 模式，显示完整的转写结果；对于 `.scp` 文件，按文件名分段显示。可以考虑加入时间戳信息（如果可用）。提供“复制结果”按钮。
        *   **“运行日志”区域:** 显示程序启动信息、依赖检查、连接尝试、文件处理步骤、来自 `simple_funasr_client.py` 的详细输出（stdout/stderr）、错误信息和调试信息。
    *   **日志级别控制:** 在“运行日志”区域旁边或程序菜单中，添加选项（如复选框）来控制日志的详细程度，例如“显示调试信息”。

**4. 生成单独的 Log 文件:**

*   **现状:** GUI 程序本身不产生日志文件。`simple_funasr_client.py` 可以通过 `--output_dir` 保存识别结果文本，但不是运行日志。
*   **改进建议:**
    *   **建议添加:** 使用 Python 内置的 `logging` 模块是标准做法。
        *   在 `funasr_gui_client_v2.py` 中配置 `logging`，将日志同时输出到“运行日志”区域（见上一点）和文件（例如 `funasr_gui_client.log`）。
        *   日志文件应包含时间戳、日志级别（INFO, WARNING, ERROR, DEBUG）和详细消息。
        *   考虑实现日志轮转 (`RotatingFileHandler`)，防止日志文件无限增大。
        *   在 GUI 中提供一个菜单项或按钮，方便用户“打开日志文件所在目录”或“查看日志文件”。
        *   确保捕获并记录 `simple_funasr_client.py` 子进程的标准输出和错误流到日志文件。

**5. 其他迭代功能点:**

*   **支持 Online 和 2Pass 模式:** 这是扩展功能的关键一步。需要在 GUI 添加模式选择，并处理这两种模式特有的参数（chunk size/interval）和实时返回的中间结果。
*   **支持热词文件:** 在 GUI 添加一个“选择热词文件”的按钮和路径显示框，并将路径传递给 `--hotword` 参数。可以在旁边加一个简单的说明，提示文件格式（`热词 权重`）。
*   **配置输出目录:** 允许用户在 GUI 中指定 `--output_dir`，用于保存 `simple_funasr_client.py` 输出的识别结果文件 (`text.{id}` 或类似名称)。完成后可以提示用户结果已保存，并提供“打开输出目录”的按钮。
*   **增强错误处理:** 对常见的错误（网络连接失败、文件不存在、格式不支持、服务器返回错误等）进行捕获，并在 GUI 中以更友好的方式（例如弹窗或状态栏红色提示）告知用户，而不是仅仅显示原始错误堆栈。
*   **添加“取消”功能:** 对于耗时较长的识别任务，应提供一个“取消”按钮来中止当前的识别过程（需要终止子进程或关闭 WebSocket 连接）。
*   **多文件处理体验:** 当用户选择 `.scp` 文件时，可以在日志或状态栏显示正在处理哪个文件，以及总体进度。
*   **配置持久化:** 将用户上次使用的服务器 IP、端口、高级选项（ITN, SSL 等）保存到配置文件或注册表（Windows），下次启动时自动加载，提升体验。
*   **UI/UX 细节打磨:** 调整控件间距、对齐，为按钮和选项添加 Tooltips 提示，使界面更美观易用。
*   **打包与分发:** 使用 PyInstaller 或类似工具将应用打包成可执行文件，方便非开发用户使用，并确保包含所有依赖。

**总结优先级:**

我认为 **(3) 结果与日志分离** 和 **(4) 生成日志文件** 对提升当前 `offline` 模式下的可用性和问题排查能力最为直接有效，应优先考虑。其次是 **(1) 状态栏信息优化** 和 **(5) 增强错误处理** 与 **添加“取消”功能**。然后可以考虑添加 **(5) 热词支持** 和 **配置输出目录**。

**上传速度优化 (2)** 对于 `offline` 模式可能只需简单调整（如使用 `--send_without_sleep`），影响相对有限。而支持 **Online/2Pass 模式** 是更大的功能扩展，优先级取决于你的需求，但这通常会带来对 (2) 中分块参数配置的需求。

希望这些建议能帮助你规划后续的开发迭代！
